# 事务

事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。目的是为了保证数据的最终一致性。

## 事务的四个特性ACID

- 原子性（Atomicity）
事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。
- 一致性（Consistency）
指在事务开始之前和事务结束以后，数据不会被破坏。
假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。
- 隔离性（Isolation）
多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。
- 持久性（Durability）
表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中

## 事务并发存在的问题

事务并发会 引起脏读、不可重复读、幻读问题。

### 脏读

如果一个事务读取到另一个未提交事务修改过的数据，我们就称发生了脏读现象。

例子
假设现在有两个事务 A、B：

假设现在 A 的余额是 100，事务 A 正在准备查询Jay的余额
事务 B 先扣减 Jay 的余额，扣了 10，但是还没提交
最后 A 读到的余额是 90，即扣减后的余额

因为事务 A 读取到事务 B 未提交的数据,这就是脏读。

### 不可重复读

同一个事务内，前后多次读取，读取到的数据内容不一致

例子
假设现在有两个事务 A 和 B：

事务 A 先查询Jay的余额，查到结果是100

这时候事务 B 对 Jay 的账户余额进行扣减，扣去 10 后，提交事务

事务 A 再去查询 Jay 的账户余额发现变成了 90


事务 A 被事务 B 干扰到了！在事务 A 范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。

### 幻读

如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），就意味着发生了幻读。

例子
假设现在有两个事务A、B：

事务A先查询id大于2的账户记录，得到记录id=2和id=3的两条记录
这时候，事务B开启，插入一条id=4的记录，并且提交了
事务A再去执行相同的查询，却得到了id=2,3,4的3条记录了。

事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入新的数据，并提交事务，然后事务 A 再次查询相同的范围，两次读取到的结果集却不一样了，这就是幻读。

## 解决事务并发问题-隔离级别

为了解决并发事务存在的脏读、不可重复读、幻读等问题，数据库大叔设计了四种隔离级别。分别是读未提交，读已提交，可重复读，串行化（Serializable）。

- 读未提交
读未提交隔离级别，只限制了两个数据不能同时修改，但是修改数据的时候，即使事务未提交，都是可以被别的事务读取到的；
这级别的事务隔离有脏读、重复读、幻读的问题。
- 读已提交
读已提交隔离级别，当前事务只能读取到其他事务提交的数据。
所以这种事务的隔离级别解决了脏读问题，但还是会存在重复读、幻读问题。
- 可重复读
可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以解决了重复读的问题。
但是读取范围数据的时候，是可以插入数据，所以还会存在幻读问题；
- 串行化
事务最高的隔离级别，在该级别下，所有事务都是进行串行化顺序执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。

|隔离级别|脏读|不可重复读|幻读|
|--|--|--|--|
|读未提交|√|√|√|
|读已提交|×|√|√|
|可重复读|×|×|√|
|串行化|×|×|×|

### ANSI SQL 隔离级别

https://www.nebula-graph.com.cn/posts/transaction-isolation

https://nan01ab.github.io/2017/08/ANSI-SQL-Isolation-Levels.html