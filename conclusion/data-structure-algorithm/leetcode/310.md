对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。

格式

该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。

你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-height-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

题目给的input是告诉你有 N 个节点和一些 edges，请你返回最小高度树的根节点。虽然让你返回的是树的根节点，但是其实这是一道图论的题，意思是返回一个节点，他到图中其他节点的距离之和最小。

思路是类似于课程表那样的拓扑排序（参考引用）。根据题意，如果需要知道谁是根节点，那么一定需要计算每两个节点之间的距离。那么对于每个节点，我们可以先统计他们的入度 indegree。这里的入度其实不是非常准确，因为两个节点中间连接的edge是双向的，而不像课程表题那样是单向的。我们这里暂且这样说，其实这里的意思是对于每个节点，统计它有几条边相连。

indegree最小的节点一定不是要找的根节点，因为这些入度为1的节点相当于是在图的最外层，而且 indegree 最小的节点的 indegree 应该是1。既然题目说了是树，就不会有环或者其他corner case。所以还是像课程表题那样，创建一个queue，优先处理入度小的节点。从queue中弹出节点的时候，也需要再次遍历每个弹出节点的邻居节点，并且把每个邻居节点的入度 - 1。此时如果有邻居节点的入度为1的，也加入queue继续循环。while循环退出的时候，queue中剩下的所有节点（有可能有多个），即是题意要求的最小高度树的根节点。

时间O(n)

空间O(n)

class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> res = new ArrayList<>();
        // corner case
        if (n == 1) {
            res.add(0);
            return res;
        }

        // normal case
        int[] degree = new int[n];
        HashMap<Integer, List<Integer>> g = new HashMap<>();
        for (int i = 0; i < n; i++) {
            g.put(i, new ArrayList<>());
        }
        for (int[] e : edges) {
            g.get(e[0]).add(e[1]);
            g.get(e[1]).add(e[0]);
            degree[e[0]]++;
            degree[e[1]]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1) {
                queue.offer(i);
            }
        }
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                list.add(cur);
                for (int nei : g.get(cur)) {
                    degree[nei]--;
                    if (degree[nei] == 1) {
                        queue.offer(nei);
                    }
                }
            }
            res = list;
        }
        return res;
    }
}