矩阵中的最长递增路径。

给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-increasing-path-in-a-matrix
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

题意是给一个二维矩阵，找出最长的递增路径。例子应该很好地解释了什么叫做最长的递增路径。

这道题也是偏 flood fill 那一类的题。因为路径是连续的且只是往上下左右四个方向，所以需要再创建一个同样 size 的二维数组来记录遍历的结果，否则会超时。二维数组内每个坐标上记录的值的意思是从当前的点 (x, y) 出发能得到的最长路径是多少。

还是应用 DFS 的模板，但是在设计 dfs 函数的时候记得加一个额外的二维数组记录结果。其余的部分可参见代码。

时间O(mn)

空间O(mn) - 额外数组缓存结果

Java实现

class Solution {
    int m;
    int n;

    public int longestIncreasingPath(int[][] matrix) {
        // corner case
        if (matrix == null || matrix.length == 0) {
            return 0;
        }

        // normal case
        m = matrix.length;
        n = matrix[0].length;
        int res = 0;
        int[][] memo = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (memo[i][j] == 0) {
                    res = Math.max(res, dfs(matrix, memo, i, j));
                }
            }
        }
        return res;
    }

    private int dfs(int[][] matrix, int[][] memo, int x, int y) {
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int res = 1;
        int m = matrix.length;
        int n = matrix[0].length;
        // 如果已经访问过则返回记录的value
        if (memo[x][y] > 0) {
            return memo[x][y];
        }
        for (int[] dir : dirs) {
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            // 越界就continue
            // 如果不是更大的数字也continue
            if (nextX < 0 || nextY < 0 || nextX >= m || nextY >= n || matrix[nextX][nextY] <= matrix[x][y]) {
                continue;
            }
            // 记住路径长度要+1
            res = Math.max(res, dfs(matrix, memo, nextX, nextY) + 1);
        }
        memo[x][y] = res;
        return res;
    }
}