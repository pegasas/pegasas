给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/evaluate-division
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这个题其实是可以用并查集做的，不过这道题的难点是并查集是带权重的，想不清楚很容易错。我这里暂时提供一个 DFS 的思路。

equations 里面的每一对字母组合 [a, b] 代表 a / b，结果在 values 数组对应的 index 下。我们可以把这个算式理解为图中从点 A 到点 B，向量的值为 values[index]，同时，图中从点 B 到点 A，向量的值为 1.0 / values[index]。所以其实这是一个带有权重的图。

我们可以利用这些信息把图先建立起来，接着用 DFS，遍历的时候，用一个变量 temp 记录中间结果。中间结果的意思是比如在图中你从 A 点出发只能到 B 点（B 是 A 的邻居节点但是 C 不是），从 B 点出发只能到 C 点的话，那么我们需要先用一个变量把从 A 到 B 的向量值记录下来，才能继续之后的递归。

时间O(V + E)

空间O(n)

Java实现

class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        HashMap<String, HashMap<String, Double>> g = new HashMap<>();
        buildGraph(g, equations, values);
        double[] res = new double[queries.size()];
        // 默认值是-1，表示找不到对应的计算结果
        Arrays.fill(res, -1.0);
        // 表示处理到第几个query了
        int index = 0;
        for (List<String> q : queries) {
            String a = q.get(0);
            String b = q.get(1);
            if (!g.containsKey(a) || !g.containsKey(b)) {
                index++;
                continue;
            } else {
                dfs(g, a, b, res, index, new HashSet<>(), 1.0);
                index++;
            }
        }
        return res;
    }

    private void buildGraph(HashMap<String, HashMap<String, Double>> g, List<List<String>> equations, double[] values) {
        int index = 0;
        for (List<String> e : equations) {
            String a = e.get(0);
            String b = e.get(1);
            g.putIfAbsent(a, new HashMap<>());
            g.putIfAbsent(b, new HashMap<>());
            // 记录a / b
            g.get(a).put(b, values[index]);
            // 记录 b / a
            g.get(b).put(a, 1.0 / values[index]);
            index++;
            // a / a和b / b都是1
            g.get(a).put(a, 1.0);
            g.get(b).put(b, 1.0);
        }
    }

    // visited表示访问过哪些节点
    // temp表示中间的计算结果
    private void dfs(HashMap<String, HashMap<String, Double>> g, String a, String b, double[] res, int index,
            HashSet<String> visited, double temp) {
        visited.add(a);
        if (g.get(a) == null || g.get(a).size() == 0) {
            return;
        }
        if (g.get(a).containsKey(b)) {
            res[index] = g.get(a).get(b) * temp;
            return;
        }
        for (String next : g.get(a).keySet()) {
            if (visited.contains(next)) {
                continue;
            }
            dfs(g, next, b, res, index, visited, g.get(a).get(next) * temp);
        }
    }
}