490. The Maze 和 505. The Maze II 迷宫 II 的变形，在二维空间中放了洞，用u, r, d, l 这四个字母来分别表示上右下左，求让球掉入洞中的最小移动距离的移动方向字符串。在步数相等的情况下，返回按字母排序最小的答案。

解法1: BFS

解法2: DFS

Java：BFS，时间复杂度O(m * n * Max(m,n))，空间复杂度O(mn)

class Solution {
    class Point {
        int row, col, dist;
 
        public Point(int row, int col, int dist) {
            this.row = row;
            this.col = col;
            this.dist = dist;
        }
    }
 
    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        if (maze == null || maze.length == 0) {
            return "";
        }
 
        int m = maze.length, n = maze[0].length;
        int[][] distance = new int[m][n];
 
        for (int i = 0; i < m; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }
 
        distance[ball[0]][ball[1]] = 0;
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        String[] ways = {"u", "d", "l", "r"};
 
        Map<Integer, String> map = new HashMap<>();
 
        Queue<Point> queue = new LinkedList<>();
        queue.add(new Point(ball[0], ball[1], 0));
 
        findShortestWayByBFS(maze, queue, map, distance, hole, ways, directions);
 
        return map.containsKey(hole[0] * n + hole[1]) ? map.get(hole[0] * n + hole[1]) : "impossible";
    }
 
    public void findShortestWayByBFS(int[][] maze, Queue<Point> queue, Map<Integer, String> map, int[][] distance, int[] hole, String[] ways, int[][] directions) {
        int n = maze[0].length;
 
        while (!queue.isEmpty()) {
            Point curPoint = queue.remove();
 
            for (int i = 0; i < 4; i++) {
                int row = curPoint.row, col = curPoint.col, dist = curPoint.dist;
                String path = map.getOrDefault(row * n + col, "");
 
                while (isValid(row, col, maze, hole)) {
                    row += directions[i][0];
                    col += directions[i][1];
                    ++dist;
                }
 
                if (row != hole[0] || col != hole[1]) {
                    row -= directions[i][0];
                    col -= directions[i][1];
                    --dist;
                }
 
                path += ways[i];
 
                if (dist < distance[row][col]) {
                    distance[row][col] = dist;
                    map.put(row * n + col, path);
                    queue.add(new Point(row, col, dist));
                }
                else if (dist == distance[row][col] && path.compareTo(map.getOrDefault(row * n + col, "")) < 0) {
                    map.put(row * n + col, path);
                    queue.add(new Point(row, col, dist));
                }
            }
        }
    }
 
    public boolean isValid(int row, int col, int[][] maze, int[] hole) {
        return row >= 0 && row < maze.length && col >= 0 && col < maze[0].length && maze[row][col] == 0 && (row != hole[0] || col != hole[1]);
    }
}　　