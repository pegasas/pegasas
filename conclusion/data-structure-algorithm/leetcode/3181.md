题目描述
给你一个整数数组 rewardValues，长度为 n，代表奖励的值。

最初，你的总奖励 x 为 0，所有下标都是 未标记 的。你可以执行以下操作 任意次：

从区间 [0, n - 1] 中选择一个 未标记 的下标 i。
如果 rewardValues[i] 大于 你当前的总奖励 x，则将 rewardValues[i] 加到 x 上（即 x = x + rewardValues[i]），并 标记 下标 i。
以整数形式返回执行最优操作能够获得的 最大 总奖励。

样例
输入：rewardValues = [1,1,3,3]

输出：4

解释：

依次标记下标 0 和 2，总奖励为 4，这是可获得的最大值。
输入：rewardValues = [1,6,4,3,2]

输出：11

解释：

动态规划，Bitset 优化




C++ 代码



const int M = 100010;
class Solution {
public:
    int maxTotalReward(vector<int>& rewardValues) {
        sort(rewardValues.begin(), rewardValues.end());

        rewardValues.resize(
                unique(rewardValues.begin(), rewardValues.end())
                - rewardValues.begin()
        );

        bitset<M> f;
        f.set(0);

        for (int x : rewardValues)
            f |= f << (M - x) >> (M - 2 * x);

        for (int i = 2 * rewardValues.back() - 1; i >= 0; i--)
            if (f[i])
                return i;

        return 0;
    }
};